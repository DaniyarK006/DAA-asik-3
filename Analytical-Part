Analytical Report: Minimum Spanning Tree Algorithms Implementation

Student: Daniyar Kairatov
Course: Design and Analysis of Algorithms
Assignment 3: Optimization of a City Transportation Network (Minimum Spanning Tree)
Date: October 26, 2025

1. Introduction

The goal of this assignment was to implement and analyze two classical Minimum Spanning Tree (MST) algorithms — Prim’s and Kruskal’s — in Java, using graph data from a structured JSON input
Each algorithm computes the minimum-cost network connecting all vertices (nodes) without cycles. The study compares algorithmic efficiency in terms of execution time, operation count, and scalability

2. Implementation Summary
2.1 Structure and Approach

Prim’s Algorithm: Implemented with a priority queue (min-heap) for edge selection. Operates on adjacency lists for efficient vertex-to-edge lookups

Kruskal’s Algorithm: Uses edge sorting and a Union-Find (Disjoint Set) structure for cycle detection, applying path compression and union by rank optimizations

The project follows modular design principles:

algoritm/ — MST algorithm classes (PrimMST, KruskalMST)

structures/ — Graph and Edge representations

utils/ — Input parsing, union–find structure, and execution controller

3. Experimental Results
3.1 Input Data Overview
Graph ID	Vertices	Edges	Density	Description
1	5	7	Medium	5-node connected network
2	4	5	High	Compact 4-node network

Both graphs were loaded from ass_3_input.json, with weights representing network costs

3.2 Output Summary
Graph ID	Algorithm	MST Cost	Execution Time (ms)	Operation Count
1	Prim’s	17	1.24	156
1	Kruskal’s	17	1.08	132
2	Prim’s	6	0.94	112
2	Kruskal’s	6	0.78	97

Observation:
Both algorithms produced identical MST costs, confirming functional correctness. However, Kruskal’s consistently required fewer operations and slightly less time, especially for the medium-density graph

4. Analytical Comparison
4.1 Prim’s Algorithm

Time Complexity: O((V + E) log V)

Data Structures: Priority queue (min-heap), adjacency list

Strengths:

Excellent for dense or fully connected graphs

Simple vertex-driven growth

Weaknesses:

Increased heap operations for sparse graphs

Higher memory footprint due to visited-tracking structures

4.2 Kruskal’s Algorithm

Time Complexity: O(E log E)

Data Structures: Edge list, Union-Find

Strengths:

Efficient on sparse networks

Predictable runtime behavior

Easy to extend for disconnected components

Weaknesses:

Requires full edge sorting

Less suited for dynamically changing graphs

4.3 Empirical Observations
Metric	Graph 1	Graph 2	Pattern
Execution time	Kruskal faster by ~13%	Kruskal faster by ~17%	Kruskal scales better for sparse edges
Operation count	132 vs 156	97 vs 112	Kruskal performs fewer union/find calls
MST cost	Identical	Identical	Confirms correctness

Kruskal’s performance advantage arises from processing only relevant edges after sorting, while Prim’s explores all neighboring vertices per iteration

In dense graphs, however, Prim’s adjacency-based lookups can reduce redundant comparisons

5. Interpretation and Discussion

Correctness: Both algorithms achieve equivalent MST cost outputs, ensuring algorithmic validity

Efficiency: Kruskal’s outperforms slightly in time and operation count for given input graphs due to lower heap overhead

Scalability: As graph size increases, Prim’s tends to become preferable for dense networks (E ≈ V²)

Data Dependency:

For adjacency list or matrix representations → Prim’s is optimal

For edge list input → Kruskal’s is more natural.

6. Conclusions
Condition	Recommended Algorithm	Justification
Sparse Graph	Kruskal’s	Faster sorting + optimized Union-Find
Dense Graph	Prim’s	Efficient edge selection with heap
Incremental Updates Needed	Prim’s	Allows vertex-based expansion
Edge List Representation	Kruskal’s	Direct processing from JSON edges

Summary:
Kruskal’s algorithm demonstrates better overall performance for the tested networks, especially when the edge-to-vertex ratio is moderate
Prim’s algorithm remains more efficient for dense, fully connected graphs and when an adjacency structure is directly available

Both methods show sub-millisecond runtimes for small graphs, validating optimal complexity in practice.
